# REST

[Описание REST интерфейса](/api/rest/restful.yaml)

![scheme](/api/rest/rest.png)

# Event Notification
[Описание ASYNC интерфейса](/api/event-notificaton/notification.yaml)
[Описание REST интерфейса](/api/event-notificaton/rest.yaml)

![scheme](/api/event-notificaton/notification.png)

# Event Collaboration

[Описание интерфейса](/api/event-collaboration/collaboration.yaml)

![scheme](/api/event-collaboration/collaboration.png)


# Предпочтительный вариант
В данном случае предпочтительным вариантом будет способ REST.
1. Большинство действий пользователя являются синхронными: положить деньги на счёт, сделать заказ. Если что-то пойдёт не так, то мы должны быстро оповестить клиента. Почтовое взаимодействие при этом не является real-tame каналом, так как зависит от внешних провайдеров.
2. Сервис отправки почты может реализовать внутри себя очередь отправки, если внешний провайдер не отвечает.

Главный минус подхода - его надёжность, так как если упадёт один сервис, то вся система будет недоступна. Что бы повысить надёжность, нужно внедрять стратегии обработки ошибок либо внутри сервисов, либо средствами service-mash


----
В варианте Event Collaboration, убирая синхронное межсервисное взаимодействие мы повышаем надежность системы, так как отказ одного сервиса не влечёт недоступность всей системы.
Но не всегда сделать все запросы асинхронными мы можем, часть действий должны происходить в онлайн.
тело событий содержит всю необходимую для обработки информацию. Каждый сервис должен хранить локальную копию данных, например, сервисы нотификаций и заказа должны слушать топик создания клиента для обеспечения согласованности информации по клиенту.

